/**
 * cwc - a crossword compiler. Copyright 1999 Lars Christensen
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA. 
 **/

#include <fstream>
#include <algo.h>

#include "letterdict.hh"


/*
                         1   2   3   4   5
   word length         +---+---+---+---+--
                       |   |   | O |   |
                       +---+---+-+-+---+---
                                 |
          position               V 1   2   3   4
                                 +---+---+---+---+--
                                 |   | O |   |   |
                                 +---+-|-+---+---+---
                                       |
                                       V a   b   c   d   e
                                       +---+---+---+---+--
                                       |   | O |   |   |
                                       +---+-|-+---+---+---

*/				                                              

                                      
//////////////////////////////////////////////////////////////////////
// letterdict

letterdict::letterdict() : p(0), all(0) {
}

template<class T>
T **newptrarray(int n) {
  T **p = new T*[n];
  for (int i=0;i<n;i++) p[i] = 0;
  return p;
}

void letterdict::addword(symbol *st, int wordi) {
  if (p == 0)
    p = newptrarray<intvec**>(MAXWORDLEN);
  if (all == 0)
    all = newptrarray<symbolset>(MAXWORDLEN);
  
  int wlen = wordlen(st);
  if (p[wlen] == 0)
    p[wlen] = newptrarray<intvec*>(wlen);

  if (all[wlen] == 0) {
    all[wlen] = new symbolset[wlen];
    for (int i=0; i<wlen; i++) all[wlen][i] = 0;
  }

  // for each position in the word
  for (int pos=0; pos<wlen; pos++) {
    if (p[wlen][pos] == 0)
      p[wlen][pos] = newptrarray<intvec>(32);
    int chval = st[pos].symbvalue();
    if (p[wlen][pos][chval] == 0)
      p[wlen][pos][chval] = new intvec;
    p[wlen][pos][chval]->push_back(wordi);

    all[wlen][pos] |= st[pos].getsymbolset();

  } // pointer hell :-)
}

letterdict::intvec letterdict::emptyvec;

letterdict::intvec *letterdict::getintvec(int len, int pos, symbol s) {
  if (p[len] == 0) return &emptyvec;
  if (p[len][pos] == 0) return &emptyvec;
  int chval = s.symbvalue();
  if (p[len][pos][chval] == 0) return &emptyvec;
  return p[len][pos][chval];
}

symbolset letterdict::findpossible(symbol *s, int len, int pos) {
  if (len == 1) return wl->allalpha;

  intvec *chpset[len];
  int nsets = 0;

  for (int i=0;i<len;i++)
    if (s[i] != symbol::empty)
      chpset[nsets++] = getintvec(len, i, s[i]);

  // cout << nsets << " sets\n";
  if (nsets == 0) {
    if (all[len] == 0)
      return 0;
    // dumpset(all[len][pos]);
    return all[len][pos];
  }

  symbolset ss = 0;

  intvec::iterator it[nsets];
  for (int i=0;i<nsets; i++) {
    it[i] = chpset[i]->begin();
    if (it[i] == chpset[i]->end())
      goto done;
  }

  // find intersection among sets

  while (1) {
    // check if all iterators point to same word
    bool allequal = true;
    for (int i = 0; i < nsets-1; i++)
      allequal &= (*it[i] == *it[i+1]);
    if (allequal) {
      // for (int i=0; i<nsets; i++)
      // cout << (*wl)[*it[i]] << ' ';
      // cout << endl;
      int wnum = *it[0];
      ss |= (*wl)[wnum][pos].getsymbolset();

      for (int i=0;i<nsets;i++) {
	it[i]++;
	if (it[i] == chpset[i]->end())
	  goto done;
      }
	  
    } else {
    
      // increment the smallest iterator
      int sm = 0;
      for (int i = 1; i < nsets; i++)
	if (*it[i] < *it[sm])
	  sm = i;
      it[sm]++;
      if (it[sm] == chpset[sm]->end())
	break;
    }
  }
 done:
  // dumpset(ss);

  return ss;
}

void letterdict::load(const string &fn) {
  cout << "Loading wordlist and building dictionary... " << flush;

  wl = new wordlist();
  wl->load(fn);

  int nwords = wl->numwords();
  for (int i=0; i<nwords; i++)
    addword((*wl)[i], i);

  cout << "ok" << endl;
}
